<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Skeletal System</title>
    <style>
        :root {
            --glow-color: #00a2ff;
            --header-height: 45px;
            --sidebar-width: 350px;
        }

        body {
            background-color: #000;
            background-image:
                linear-gradient(to right, rgba(0, 162, 255, 0.3) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0, 162, 255, 0.3) 1px, transparent 1px);
            background-size: 20px 20px;
            margin: 0;
            font-family: Calibri, Candara, Segoe, "Segoe UI", Optima, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: var(--header-height);
            background-color: #000;
            color: #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 5000;
            border-bottom: 1px solid #222;
        }

        .header-title {
            font-size: 1.1em;
            font-weight: bold;
            color: var(--glow-color);
            text-transform: uppercase;
            cursor: pointer;
        }

        .header-title:hover {
            text-shadow: 0 0 8px var(--glow-color);
        }

        nav.center-nav a,
        nav.right-nav a {
            color: #ccc;
            text-decoration: none;
            margin: 0 12px;
            font-size: 0.9em;
            transition: color 0.2s ease, text-shadow 0.2s ease;
            cursor: pointer;
        }

        nav.center-nav a:hover,
        nav.right-nav a:hover {
            color: #fff;
            text-shadow: 0 0 8px var(--glow-color);
        }

        .main-content {
            margin-top: var(--header-height);
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* Needed for absolute positioning of container */
            width: 100%;
            overflow: hidden; /* Prevent content overflow issues */
        }

        .container {
            position: relative; /* Children positioned relative to this */
            margin: 20px;
            cursor: default;
            transition: transform 0.5s ease-in-out;
            max-width: calc(100vw - var(--sidebar-width) - 60px); /* Adjust max width considering sidebar */
            max-height: calc(100vh - var(--header-height) - 40px); /* Adjust max height */
            flex-shrink: 0; /* Prevent container from shrinking */
            /* width and height will be set dynamically by JS */
        }

        .container img.anatomy-layer {
             /* Let natural dimensions dictate size, scale down if needed */
              max-width: 100%;
              max-height: 100%;
              width: auto; /* Maintain aspect ratio */
              height: auto; /* Maintain aspect ratio */
              display: block; /* Prevents extra space below images */
        }

        .anatomy-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Make layers fill the container set by JS */
            height: 100%;
            pointer-events: none; /* Allow clicks/hovers to pass through */
            user-select: none;
            -webkit-user-drag: none;
            transition: filter 0.15s ease-in-out, opacity 0.3s ease-in-out;
            opacity: 1;
            object-fit: contain; /* Ensure images fit within bounds */
        }

        .anatomy-layer.hidden {
             opacity: 0;
             pointer-events: none; /* Ensure hidden layers are not interactive */
        }

        .hit-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Match container size */
            height: 100%;
            pointer-events: none; /* Should not block mouse events intended for container */
            visibility: hidden; /* Not visible to user */
        }

        .glowing {
            /* Apply glow effect using drop-shadow filter */
            filter: drop-shadow(0 0 15px var(--glow-color));
        }

        #loading {
            color: white;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            z-index: 10000;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            border-radius: 8px;
            text-align: center;
        }
         #loading progress {
             width: 80%;
             margin-top: 10px;
         }

        #sidebar {
            position: fixed;
            right: 0;
            top: var(--header-height);
            width: var(--sidebar-width);
            height: calc(100vh - var(--header-height));
            background-color: rgba(15, 15, 15, 0.98);
            color: #eee;
            border-left: 1px solid #333;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
            z-index: 4000;
            transform: translateX(100%);
            transition: transform 0.4s ease-in-out;
            display: flex;
            flex-direction: column;
        }

        #sidebar.visible {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 15px 20px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .sidebar-header h4 {
            margin: 0;
            color: var(--glow-color);
            font-size: 1.3em;
        }

        .sidebar-close-btn {
            background: none;
            border: none;
            color: #aaa;
            font-size: 1.8em;
            line-height: 1; /* Adjust line height for better alignment */
            cursor: pointer;
            padding: 0 5px;
            transition: color 0.2s ease;
        }

        .sidebar-close-btn:hover {
            color: #fff;
        }

        .sidebar-content {
            padding: 20px;
            overflow-y: auto; /* Enable scrolling for content */
            flex-grow: 1; /* Allow content to fill remaining space */
        }

        /* Style images within the sidebar */
        .sidebar-content img.popup-gif,
        .sidebar-content img.popup-image {
            max-width: 100%; /* Ensure images don't overflow sidebar */
            height: auto;
            margin-bottom: 15px;
            border-radius: 5px;
            background-color: #222; /* Placeholder background */
            display: block; /* Prevent extra space */
        }

        /* Styling for text elements in sidebar */
        .sidebar-content h5 {
             color: #bbb;
             margin-top: 20px;
             margin-bottom: 8px;
             border-bottom: 1px solid #333;
             padding-bottom: 4px;
         }
         .sidebar-content p {
             font-size: 0.95em;
             line-height: 1.6;
             margin-bottom: 15px;
             color: #ccc;
         }
         .sidebar-content a {
             color: var(--glow-color);
             text-decoration: none;
         }
         .sidebar-content a:hover {
             text-decoration: underline;
         }
         .sidebar-content ul {
             list-style: none; /* Remove default list styling */
             padding-left: 0;
         }
         .sidebar-content li {
             margin-bottom: 8px;
             font-size: 0.9em;
             color: #bbb;
         }
         .sidebar-content .credits {
             margin-top: 30px;
             padding-top: 15px;
             border-top: 1px solid #333;
             font-size: 0.8em;
             color: #888;
         }
         .sidebar-content .credits h5 {
             color: #aaa;
             margin-bottom: 10px;
         }

    </style>
</head>
<body>
    <header>
        <div class="header-title" id="header-title">SKELETAL SYSTEM</div>
        <nav class="center-nav">
            <a href="#" data-mode="arthritis">Arthritis</a>
            <a href="#" data-mode="osteoporosis">Osteoporosis</a>
            <a href="#" data-mode="osteomyelitis">Osteomyelitis</a>
            <a href="#" data-mode="scoliosis">Scoliosis</a>
            <a href="#" data-mode="rickets">Rickets</a>
        </nav>
        <nav class="right-nav">
            <a href="https://ashish102005.github.io/kurkure/" target="_blank" rel="noopener noreferrer">Take a Quiz</a>
            <a href="#" data-mode="about">About</a>
        </nav>
    </header>

    <div class="main-content">
        <div class="container" id="container">
            </div>
    </div>

    <div id="sidebar">
        <div class="sidebar-header">
            <h4 id="sidebar-title">Information</h4>
            <button class="sidebar-close-btn" id="sidebar-close-btn" aria-label="Close sidebar">&times;</button>
        </div>
        <div class="sidebar-content" id="sidebar-content">
            </div>
    </div>

    <div id="loading">
         Loading Assets...
         <progress id="loading-progress" value="0" max="100"></progress>
    </div>

    <script>
        // Constants
        const DEFAULT_BASE_IMAGE_ID = 'base-default';
        const DISEASE_BASE_IMAGE_ID = 'base-disease';
        const DEFAULT_BASE_SRC = 'test.png'; // Define default source once

        // Data Definitions
        const skeletonLayers = [
             { id: 'skull', src: 'skull.png', name: 'Skull', interactive: true, gifSrc: 'skull.gif', info: 'The skull protects the brain and provides structure to the face. Made up of 22 bones, it is divided into the cranium (braincase) and facial bones.' },
             { id: 'spine', src: 'spine.png', name: 'Spine', interactive: true, gifSrc: 'spine.gif', info: 'The spine, or vertebral column, consists of 33 vertebrae. It supports the body, allows movement, and protects the spinal cord.' },
             { id: 'ribcage', src: 'ribcage.png', name: 'Ribcage', interactive: true, gifSrc: 'ribcage.gif', info: 'Typically consisting of 12 pairs of ribs, the sternum, and thoracic vertebrae, the ribcage protects vital organs like the heart and lungs.' },
             { id: 'pelvis', src: 'pelvis.png', name: 'Pelvis', interactive: true, gifSrc: 'pelvis.gif', info: 'The pelvis connects the spine to the legs and supports abdominal organs. It is formed by the hip bones, sacrum, and coccyx.' },
             { id: 'right-arm', src: 'right-arm.png', name: 'Right Arm Bones', interactive: true, gifSrc: 'arm.gif', info: 'Includes the humerus (upper arm), and the radius and ulna (forearm). These bones facilitate a wide range of movements.' },
             { id: 'left-arm', src: 'left-arm.png', name: 'Left Arm Bones', interactive: true, gifSrc: 'arm.gif', info: 'Includes the humerus (upper arm), and the radius and ulna (forearm). Structurally similar to the right arm.' },
             { id: 'hands', src: 'hands.png', name: 'Hand Bones', interactive: true, gifSrc: 'hands.gif', info: 'Each hand has 27 bones: carpals (wrist), metacarpals (palm), and phalanges (fingers), allowing for dexterity.' },
             { id: 'thighs', src: 'thighs.png', name: 'Thigh Bone (Femur)', interactive: true, gifSrc: 'femur.gif', info: 'The femur is the longest, heaviest, and strongest bone in the human body, connecting the hip to the knee.' },
             { id: 'lower-leg', src: 'lower-leg.png', name: 'Lower Leg Bones', interactive: true, gifSrc: 'tibia.gif', info: 'Comprises the tibia (shin bone), which bears most of the weight, and the fibula. They connect the knee to the ankle.' },
             { id: 'feet', src: 'feet.png', name: 'Foot Bones', interactive: true, gifSrc: 'feet.gif', info: 'Each foot contains 26 bones: tarsals (ankle), metatarsals (midfoot), and phalanges (toes), providing support and enabling locomotion.' }
        ];

        const diseaseInfo = {
             arthritis: {
                 name: 'Arthritis',
                 baseImage: 'arthritis-test.png', // Specific background for this disease
                 extraLayers: [{ id: 'arthritis-hand', src: 'arthritis-hand.png', zIndex: 1000 }],
                 popupImage: 'arthritis-popj.jpeg',
                 info: 'Arthritis is the swelling and tenderness of one or more joints... [rest of info]',
                 links: [{ text: 'More on Arthritis (Mayo Clinic)', url: 'https://www.mayoclinic.org/diseases-conditions/arthritis/symptoms-causes/syc-20350772' }]
             },
             osteoporosis: {
                 name: 'Osteoporosis',
                 baseImage: 'osteoporosis-test.png', // Specific background
                 extraLayers: [{ id: 'osteoporosis-arm', src: 'osteoporosis-arm.png', zIndex: 1000 }],
                 popupImage: 'osteoporosis-pop.jpeg',
                 info: 'Osteoporosis causes bones to become weak and brittle... [rest of info]',
                 links: [{ text: 'Osteoporosis Overview (NIH)', url: 'https://www.niams.nih.gov/health-topics/osteoporosis' }]
             },
             osteomyelitis: {
                 name: 'Osteomyelitis',
                 baseImage: DEFAULT_BASE_SRC, // Use the default 'test.png' for this one
                 extraLayers: [{ id: 'osteomyelitis-arm', src: 'osteomyelitis-arm.png', zIndex: 1000 }],
                 popupImage: 'osteomyelitis-pop.png',
                 info: 'Osteomyelitis is an infection in a bone... [rest of info]',
                 links: [{ text: 'Learn about Osteomyelitis (MSD Manual)', url: 'https://www.msdmanuals.com/home/bone,-joint,-and-muscle-disorders/bone-infections/osteomyelitis' }]
             },
             scoliosis: {
                 name: 'Scoliosis',
                 baseImage: 'scoliosis2.png', // Specific background
                 extraLayers: [],
                 popupImage: 'scoliosis-popj.jpeg',
                 info: 'Scoliosis is a sideways curvature of the spine... [rest of info]',
                 links: [{ text: 'Scoliosis Information (SRS)', url: 'https://www.srs.org/patients-and-families/conditions-and-treatments/parents/scoliosis' }]
             },
             rickets: {
                 name: 'Rickets',
                 baseImage: 'rickets-test.png', // Specific background
                 extraLayers: [{ id: 'rickets-layer', src: 'rickets.png', zIndex: 1000 }],
                 popupImage: 'rickets-popj.jpeg',
                 info: 'Rickets is the softening and weakening of bones in children... [rest of info]',
                 links: [{ text: 'Rickets Explained (KidsHealth)', url: 'https://kidshealth.org/en/parents/rickets.html' }]
             },
             about: {
                 name: 'About This Project',
                 baseImage: null, // No specific base, will default to test.png display
                 extraLayers: [],
                 popupImage: null,
                 info: `<h5>Skeletal System as Scaffold</h5>
                       <p>This interactive tool explores the human skeletal system...</p>
                       <div class="credits">
                           <h5>Project Credits</h5>
                           <ul>
                               <li>10484 - Ashish Kori</li>
                               <li>10483 - Samruddhi Khapare</li>
                               <li>10474 - Darshan Bhoir</li>
                               <li>10476 - Jayesh Devlekar</li>
                               <li>10477 - Paras Dhende</li>
                               <li>10479 - Manomay Ghadi</li>
                               <li>10480 - Isha Madhialagan</li>
                               <li>10482 - Sayli Kargutkar</li>
                               <li>10478 - Jess Demello</li>
                               <li>10481 - Abhinav Jha</li>
                               <li>10475 - Luke Cabral</li>
                           </ul>
                       </div>`
             }
        };

        // DOM Elements
        const container = document.getElementById('container');
        const loadingIndicator = document.getElementById('loading');
        const loadingProgress = document.getElementById('loading-progress');
        const sidebar = document.getElementById('sidebar');
        const sidebarTitle = document.getElementById('sidebar-title');
        const sidebarContent = document.getElementById('sidebar-content');
        const sidebarCloseBtn = document.getElementById('sidebar-close-btn');
        const header = document.querySelector('header');
        const headerTitle = document.getElementById('header-title');

        // State Variables
        const imageElements = {}; // Store image elements by ID
        const canvasElements = {}; // Store hit canvas elements by ID
        const canvasContexts = {}; // Store canvas contexts by ID
        let assetsToLoad = 0;
        let assetsLoaded = 0;
        let activeLayerId = null; // ID of the currently hovered interactive layer
        let currentMode = 'default'; // 'default', 'arthritis', 'about', etc.
        let baseImageNaturalWidth = 0; // Store original dimensions of default base
        let baseImageNaturalHeight = 0;

        // --- Initialization ---
        function init() {
            console.log("Initializing...");
            setupHeaderListeners();
            sidebarCloseBtn.addEventListener('click', closeSidebar);

            headerTitle.addEventListener('click', () => {
                // Reload or reset to default state
                // window.location.reload(); // Full reload
                setMode('default'); // Reset to default mode without reload
            });

            // Collect all unique image URLs to preload
            const imageUrls = new Set();
            imageUrls.add(DEFAULT_BASE_SRC); // Default base
            skeletonLayers.forEach(l => imageUrls.add(l.src));
            Object.values(diseaseInfo).forEach(d => {
                if (d.baseImage && d.baseImage !== DEFAULT_BASE_SRC) imageUrls.add(d.baseImage); // Unique disease bases
                if (d.popupImage) imageUrls.add(d.popupImage);
                d.extraLayers.forEach(el => imageUrls.add(el.src));
            });
            skeletonLayers.forEach(l => { if (l.gifSrc) imageUrls.add(l.gifSrc); });

            assetsToLoad = imageUrls.size;
            console.log(`Need to load ${assetsToLoad} assets.`);
            loadingProgress.max = assetsToLoad;

            if (assetsToLoad === 0) {
                console.warn("No assets found to load.");
                setupScene(); // Try to setup anyway
                return;
            }

            // Create TWO base layers (one default, one for disease backgrounds)
            createLayerElement({ id: DEFAULT_BASE_IMAGE_ID, src: '', name: 'Base Body Default', interactive: false, zIndex: 0 });
            createLayerElement({ id: DISEASE_BASE_IMAGE_ID, src: '', name: 'Base Body Disease', interactive: false, zIndex: 0, initiallyHidden: true });

            // Create skeleton layers (start zIndex higher than base)
            skeletonLayers.forEach((layer, index) => {
                createLayerElement({ ...layer, zIndex: index + 1 });
            });

            // Create disease extra layers (high zIndex)
            Object.values(diseaseInfo).forEach(disease => {
                disease.extraLayers.forEach(layerInfo => {
                    createLayerElement({ ...layerInfo, interactive: false, initiallyHidden: true, zIndex: (layerInfo.zIndex !== undefined ? layerInfo.zIndex : 1000) });
                });
            });

            // Start preloading
            imageUrls.forEach(url => {
                if (url) preloadImage(url); // Check for null/empty URLs
            });
        }

        // --- Element Creation ---
        function createLayerElement(layerData) {
            const img = new Image();
            img.className = 'anatomy-layer';
            img.id = `${layerData.id}-layer`; // Unique ID including '-layer'
            img.alt = layerData.name || layerData.id;
            img.style.zIndex = layerData.zIndex === undefined ? 1 : layerData.zIndex;
            if (layerData.initiallyHidden) {
                img.classList.add('hidden');
            }
            // Set src later in checkAllAssetsLoaded to ensure preloading works
            imageElements[layerData.id] = img; // Store reference using the simple ID (e.g., 'skull')
            container.appendChild(img);

            // Create hit canvas only for interactive skeleton layers
            if (layerData.interactive && skeletonLayers.some(sl => sl.id === layerData.id)) {
                const canvas = document.createElement('canvas');
                canvas.className = 'hit-canvas';
                canvas.id = `${layerData.id}-canvas`; // Unique canvas ID
                // zIndex higher than the image it corresponds to, for hit detection logic
                canvas.style.zIndex = (layerData.zIndex || 1) + 100;
                canvasElements[layerData.id] = canvas;
                container.appendChild(canvas);
            }
        }

        // --- Asset Loading ---
        function preloadImage(url) {
            const img = new Image();
            img.onload = () => assetLoadHandler(url);
            img.onerror = () => assetErrorHandler(url);
            img.src = url;
        }

        function assetLoadHandler(url) {
            console.log(`Loaded: ${url}`);
            assetsLoaded++;
            updateLoadingProgress();
            checkAllAssetsLoaded();
        }

        function assetErrorHandler(url) {
            showError(`Failed to load asset: ${url}`, false);
            console.error(`Failed to load asset: ${url}`);
            assetsLoaded++; // Still count as processed to finish loading sequence
            updateLoadingProgress();
            checkAllAssetsLoaded(); // Check if this was the last one
        }

        function updateLoadingProgress() {
            loadingProgress.value = assetsLoaded;
            if (loadingIndicator.style.display !== 'none') {
                // Update text content safely
                loadingIndicator.firstChild.textContent = ` Loading Assets... (${assetsLoaded}/${assetsToLoad}) `;
            }
        }

        function checkAllAssetsLoaded() {
            if (assetsLoaded >= assetsToLoad) { // Use >= in case of errors
                console.log("All assets processed. Setting up scene.");

                // Now set the src for the created image elements
                if (imageElements[DEFAULT_BASE_IMAGE_ID]) imageElements[DEFAULT_BASE_IMAGE_ID].src = DEFAULT_BASE_SRC;
                // disease base src is set dynamically

                skeletonLayers.forEach(layer => {
                    if (imageElements[layer.id]) imageElements[layer.id].src = layer.src;
                });
                Object.values(diseaseInfo).forEach(disease => {
                    disease.extraLayers.forEach(layerInfo => {
                        if (imageElements[layerInfo.id]) imageElements[layerInfo.id].src = layerInfo.src;
                    });
                });

                // Use setTimeout to allow the browser a moment to render images after src assignment
                setTimeout(setupScene, 150);
            }
        }

        // --- Scene Setup (after loading) ---
        function setupScene() {
            console.log("Setting up scene...");
            const baseDefaultImg = imageElements[DEFAULT_BASE_IMAGE_ID];

            // Wait for the default base image to be ready to get dimensions
            if (baseDefaultImg && baseDefaultImg.complete && baseDefaultImg.naturalWidth > 0) {
                 baseImageNaturalWidth = baseDefaultImg.naturalWidth;
                 baseImageNaturalHeight = baseDefaultImg.naturalHeight;
                 console.log(`Base dimensions set: ${baseImageNaturalWidth}x${baseImageNaturalHeight}`);

                 // Set initial container size
                 container.style.width = baseImageNaturalWidth + 'px';
                 container.style.height = baseImageNaturalHeight + 'px';

                 // Setup hit canvases
                 let initializationSuccess = true;
                 skeletonLayers.forEach(layer => {
                     if (!layer.interactive) return;

                     const img = imageElements[layer.id];
                     const canvas = canvasElements[layer.id];

                     if (!img || !canvas) {
                         console.warn(`Image or Canvas missing for interactive layer ${layer.id}.`);
                         return; // Skip canvas setup for this layer
                     }

                     // Wait for individual layer image to be ready
                     if (img.complete && img.naturalWidth > 0) {
                         canvas.width = img.naturalWidth;
                         canvas.height = img.naturalHeight;

                         const ctx = canvas.getContext('2d', { willReadFrequently: true });
                         if (!ctx) {
                             console.error(`Could not get 2D context for ${layer.id}`);
                             initializationSuccess = false;
                             return;
                         }
                         try {
                             ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                             canvasContexts[layer.id] = ctx;
                             console.log(`Canvas context created for ${layer.id}`);
                         } catch (e) {
                             console.error(`Error drawing image to canvas for ${layer.id}:`, e);
                             initializationSuccess = false;
                         }
                     } else {
                         // If image not ready yet, try again shortly or log error
                         console.warn(`Image for layer ${layer.id} not ready during canvas setup. Interaction might be delayed.`);
                         // Optionally, add a mechanism to retry canvas drawing onload for the specific image
                          img.onload = () => { // Add onload listener for retry
                              console.log(`Retrying canvas setup for ${layer.id} on image load.`);
                              if (canvas && img.naturalWidth > 0) {
                                 canvas.width = img.naturalWidth;
                                 canvas.height = img.naturalHeight;
                                 const ctxRetry = canvas.getContext('2d', { willReadFrequently: true });
                                 if(ctxRetry) {
                                     try {
                                         ctxRetry.drawImage(img, 0, 0, canvas.width, canvas.height);
                                         canvasContexts[layer.id] = ctxRetry; // Store context on successful retry
                                         console.log(`Canvas context successfully created for ${layer.id} on retry.`);
                                     } catch (e) {
                                         console.error(`Error drawing image to canvas on retry for ${layer.id}:`, e);
                                     }
                                 }
                              }
                          };
                     }
                 });

                 if (initializationSuccess) {
                     container.addEventListener('mousemove', handleContainerMouseMove);
                     container.addEventListener('mouseleave', handleContainerMouseLeave);
                     container.addEventListener('click', handleContainerClick);
                     loadingIndicator.style.display = 'none';
                     console.log("Initialization complete.");
                 } else {
                     showError("Initialization failed for some layers. Interaction may be incomplete.", true);
                     loadingIndicator.style.display = 'none'; // Hide loading anyway
                 }

            } else {
                 // If default base image isn't ready, wait a bit and retry setupScene
                 console.warn("Default base image not ready yet. Retrying setupScene...");
                 setTimeout(setupScene, 200); // Retry after a short delay
            }
        }


        // --- UI Interaction ---
        function setupHeaderListeners() {
            header.addEventListener('click', (e) => {
                if (e.target.tagName === 'A' && e.target.dataset.mode) {
                    e.preventDefault();
                    const mode = e.target.dataset.mode;
                    // Toggle sidebar visibility for 'about' if already open and 'about' is clicked again
                    if (mode === 'about' && sidebar.classList.contains('visible') && currentMode === 'about') {
                        closeSidebar();
                    } else {
                        setMode(mode);
                    }
                }
            });
        }

        function setMode(mode) {
            console.log(`Setting mode to: ${mode}`);
            handleContainerMouseLeave(); // Reset any active hover effects

            currentMode = mode;

            // Get references to base layers
            const defaultBaseImg = imageElements[DEFAULT_BASE_IMAGE_ID];
            const diseaseBaseImg = imageElements[DISEASE_BASE_IMAGE_ID];

            if (!defaultBaseImg || !diseaseBaseImg) {
                console.error("Base image elements not found! Cannot change mode.");
                return;
            }

            // --- Reset dynamic elements ---
            // Hide disease base layer and clear its src
            diseaseBaseImg.classList.add('hidden');
            diseaseBaseImg.src = '';
            // Hide all extra disease-specific layers
            Object.values(diseaseInfo).forEach(d => {
                d.extraLayers.forEach(l => {
                    if (imageElements[l.id]) imageElements[l.id].classList.add('hidden');
                });
            });
            // Ensure skeleton layers are visible (might have been hidden - though not currently implemented)
            skeletonLayers.forEach(l => {
                 if(imageElements[l.id]) imageElements[l.id].classList.remove('hidden');
            });
            // Always start by showing the default base (it will be hidden later if needed)
             defaultBaseImg.classList.remove('hidden');

            // --- Configure based on mode ---
            const info = diseaseInfo[mode];
            let resizeImageSource = DEFAULT_BASE_SRC; // Default resize source is test.png

            if (mode === 'default') {
                // defaultBaseImg is already visible
                closeSidebar();
                resizeImageSource = DEFAULT_BASE_SRC;
            } else if (mode === 'about') {
                // defaultBaseImg is already visible
                showSidebar(info);
                resizeImageSource = DEFAULT_BASE_SRC;
            } else if (mode === 'osteomyelitis') {
                // Use default base 'test.png'
                defaultBaseImg.classList.remove('hidden');
                diseaseBaseImg.classList.add('hidden'); // Ensure disease base is hidden

                // Show extra layers for Osteomyelitis
                if (info && info.extraLayers) {
                    info.extraLayers.forEach(l => {
                        if (imageElements[l.id]) imageElements[l.id].classList.remove('hidden');
                    });
                }
                showSidebar(info);
                resizeImageSource = DEFAULT_BASE_SRC; // Resize based on test.png

            } else if (info) { // Handles other diseases (Arthritis, Osteoporosis, Scoliosis, Rickets)
                // Hide default base ('test.png') for these diseases
                defaultBaseImg.classList.add('hidden');

                if (info.baseImage && info.baseImage !== DEFAULT_BASE_SRC) {
                    // Use the specific disease background image
                    diseaseBaseImg.src = info.baseImage;
                    diseaseBaseImg.classList.remove('hidden'); // Show the disease background
                    resizeImageSource = info.baseImage; // Resize based on this disease image
                } else {
                    // If disease has no specific base OR its base is test.png (like Osteomyelitis, though handled above), show default
                    console.warn(`Mode ${mode} requested default base or had no specific one. Showing default base.`);
                    defaultBaseImg.classList.remove('hidden');
                    diseaseBaseImg.classList.add('hidden');
                    resizeImageSource = DEFAULT_BASE_SRC;
                }

                // Show extra layers for the current disease
                if (info.extraLayers) {
                    info.extraLayers.forEach(l => {
                        if (imageElements[l.id]) imageElements[l.id].classList.remove('hidden');
                    });
                }
                showSidebar(info);

            } else {
                // Unknown mode - fallback to default
                console.warn(`Unknown mode: ${mode}. Setting to default.`);
                defaultBaseImg.classList.remove('hidden');
                diseaseBaseImg.classList.add('hidden');
                closeSidebar();
                resizeImageSource = DEFAULT_BASE_SRC;
                currentMode = 'default'; // Explicitly set back
            }


            // --- Resize container based on the determined source ---
            // Use the natural dimensions stored earlier if resizing to default,
            // otherwise load the new image to get its dimensions.
            if (resizeImageSource === DEFAULT_BASE_SRC) {
                 container.style.width = baseImageNaturalWidth + 'px';
                 container.style.height = baseImageNaturalHeight + 'px';
                 console.log(`Container resized to default dimensions for ${currentMode}.`);
            } else if (resizeImageSource) {
                 const tempImg = new Image();
                 tempImg.onload = () => {
                     if (tempImg.naturalWidth > 0 && tempImg.naturalHeight > 0) {
                         container.style.width = tempImg.naturalWidth + 'px';
                         container.style.height = tempImg.naturalHeight + 'px';
                         console.log(`Container resized using ${resizeImageSource} dimensions (${tempImg.naturalWidth}x${tempImg.naturalHeight}) for ${currentMode}.`);
                         // Potentially re-align or resize absolutely positioned children if necessary
                     } else {
                         console.warn(`Could not get dimensions for ${resizeImageSource}. Container not resized.`);
                         // Fallback to default size?
                         container.style.width = baseImageNaturalWidth + 'px';
                         container.style.height = baseImageNaturalHeight + 'px';
                     }
                 };
                 tempImg.onerror = () => {
                     console.error(`Error loading image for resizing: ${resizeImageSource}. Falling back to default size.`);
                     container.style.width = baseImageNaturalWidth + 'px';
                     container.style.height = baseImageNaturalHeight + 'px';
                 };
                 tempImg.src = resizeImageSource;
            } else {
                 console.warn("No image source determined for resizing. Using default.");
                 container.style.width = baseImageNaturalWidth + 'px';
                 container.style.height = baseImageNaturalHeight + 'px';
            }
        }


        function showSidebar(data) {
            if (!data) return;

            sidebarTitle.textContent = data.name || 'Details';
            let contentHTML = '';

            // Use popupImage first, then gifSrc if popupImage isn't available
            const imageSrc = data.popupImage || data.gifSrc;
            const imageClass = data.popupImage ? 'popup-image' : (data.gifSrc ? 'popup-gif' : '');

            if (imageSrc) {
                contentHTML += `<img src="${imageSrc}" alt="${data.name}" class="${imageClass}">`;
            }

            contentHTML += `<div>${data.info || 'No information available.'}</div>`;

            if (data.links && data.links.length > 0) {
                contentHTML += `<h5>Learn More:</h5><ul>`;
                data.links.forEach(link => {
                    contentHTML += `<li><a href="${link.url}" target="_blank" rel="noopener noreferrer">${link.text}</a></li>`;
                });
                contentHTML += `</ul>`;
            }

            sidebarContent.innerHTML = contentHTML;
            sidebar.classList.add('visible');
             // Scroll sidebar content to top when opened
             sidebarContent.scrollTop = 0;
        }

        function closeSidebar() {
            sidebar.classList.remove('visible');
            // Optional: If closing sidebar should always return to default view
            // if (currentMode !== 'default') {
            //    setMode('default');
            // }
        }

        function handleContainerMouseMove(event) {
            // Only allow hover effects in default mode when sidebar is closed or showing bone info
            if (currentMode !== 'default' || (sidebar.classList.contains('visible') && diseaseInfo[currentMode] )) {
                 handleContainerMouseLeave(); // Ensure no glow if not in correct state
                 return;
            }

            let foundLayerId = null;
             // Iterate reverse order for correct top-most layer detection
            for (let i = skeletonLayers.length - 1; i >= 0; i--) {
                const layer = skeletonLayers[i];
                if (layer.interactive && canvasContexts[layer.id] && imageElements[layer.id] && !imageElements[layer.id].classList.contains('hidden')) {
                    if (isPixelHit(event, canvasElements[layer.id], canvasContexts[layer.id])) {
                        foundLayerId = layer.id;
                        break; // Found the topmost layer under cursor
                    }
                }
            }

            // Update glow effect
            if (foundLayerId !== activeLayerId) {
                // Remove glow from previously active layer
                if (activeLayerId && imageElements[activeLayerId]) {
                    imageElements[activeLayerId].classList.remove('glowing');
                }
                // Add glow to newly active layer
                if (foundLayerId && imageElements[foundLayerId]) {
                    imageElements[foundLayerId].classList.add('glowing');
                }
                activeLayerId = foundLayerId; // Update the active layer ID
            }
        }

        function handleContainerMouseLeave() {
            // Remove glow from the currently active layer when mouse leaves container
            if (activeLayerId && imageElements[activeLayerId]) {
                imageElements[activeLayerId].classList.remove('glowing');
            }
            activeLayerId = null; // Reset active layer ID
        }

        function handleContainerClick(event) {
            // Only allow clicks to open bone info in default mode
            if (currentMode !== 'default') return;

            let clickedLayerId = null;
            for (let i = skeletonLayers.length - 1; i >= 0; i--) {
                 const layer = skeletonLayers[i];
                 if (layer.interactive && canvasContexts[layer.id] && imageElements[layer.id] && !imageElements[layer.id].classList.contains('hidden')) {
                      if (isPixelHit(event, canvasElements[layer.id], canvasContexts[layer.id])) {
                          clickedLayerId = layer.id;
                          break;
                      }
                 }
            }

            if (clickedLayerId) {
                const clickedLayerData = skeletonLayers.find(l => l.id === clickedLayerId);
                if (clickedLayerData) {
                    console.log(`Clicked on: ${clickedLayerData.name}`);
                    showSidebar(clickedLayerData); // Show info for the clicked bone
                }
            } else {
                 // Optional: Close sidebar if clicking on empty space?
                 // if (sidebar.classList.contains('visible')) {
                 //    closeSidebar();
                 // }
            }
        }

        // --- Utility Functions ---
        function isPixelHit(event, canvas, ctx) {
            if (!canvas || !ctx) return false; // Cannot check if canvas/context is missing

            const contRect = container.getBoundingClientRect(); // Use container bounds

            // Calculate mouse position relative to the container
            const mouseX = event.clientX - contRect.left;
            const mouseY = event.clientY - contRect.top;

            // Check if mouse is within the container bounds
            if (mouseX < 0 || mouseX >= container.clientWidth || mouseY < 0 || mouseY >= container.clientHeight) {
                 // console.log("Click outside container bounds");
                 return false;
            }

             // Calculate scaling factor between displayed size and canvas natural size
             // This assumes the canvas element itself is scaled to fit the container
             const scaleX = canvas.width / container.clientWidth;
             const scaleY = canvas.height / container.clientHeight;

             // Calculate corresponding pixel coordinates on the canvas's internal bitmap
             const canvasX = Math.floor(mouseX * scaleX);
             const canvasY = Math.floor(mouseY * scaleY);

            // Check if calculated canvas coordinates are valid
            if (canvasX < 0 || canvasX >= canvas.width || canvasY < 0 || canvasY >= canvas.height) {
                 // console.log("Calculated canvas coordinates out of bounds");
                 return false; // Coordinates outside the canvas's own dimensions
            }

            try {
                // Get the pixel data (alpha channel) at the calculated canvas coordinates
                const pixelData = ctx.getImageData(canvasX, canvasY, 1, 1).data;
                // Alpha value is at index 3 (R=0, G=1, B=2, A=3)
                const alpha = pixelData[3];
                // Consider a pixel 'hit' if alpha is greater than a threshold (e.g., > 0 or > 10)
                return alpha > 10; // Adjust threshold if needed (0-255 range)
            } catch (e) {
                // Error likely due to cross-origin issues if images aren't served properly,
                // or if getImageData is called before drawing is complete.
                console.error("Error reading pixel data:", e);
                return false; // Treat as miss on error
            }
        }


        function showError(message, isFatal = false) {
            console.error("Error:", message);
            // Display error to the user, potentially overlaying the loading indicator
            loadingIndicator.innerHTML = `Error: ${message}${isFatal ? '<br>Cannot continue.' : ''}`;
            loadingIndicator.style.display = 'block'; // Make sure it's visible
            loadingIndicator.style.color = 'red';
            // If fatal, maybe disable interactions or stop further execution
        }

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>